<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VoxReal: Endless Survival</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #112;
      color: white;
      font-family: monospace;
    }
    canvas {
      display: block;
      background: radial-gradient(circle at center, #123 0%, #001 100%);
    }
    #leaderboard {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.5);
      padding: 12px 20px;
      border-radius: 10px;
      font-size: 14px;
      backdrop-filter: blur(4px);
    }
    #leaderboard h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      text-align: center;
      color: #0ff;
    }
    #leaderboard ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #leaderboard li {
      margin: 4px 0;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="leaderboard">
    <h3>üåç Top 5 Scores</h3>
    <ul id="scores"></ul>
  </div>

  <!-- Game + Firebase -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import {
      getFirestore, collection, addDoc,
      getDocs, query, orderBy, limit
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyDcRddILs6XUM9HEgtLWgnpp-CYDsgT9Dc",
  authDomain: "voxreal-eb535.firebaseapp.com",
  databaseURL: "https://voxreal-eb535-default-rtdb.firebaseio.com",
  projectId: "voxreal-eb535",
  storageBucket: "voxreal-eb535.firebasestorage.app",
  messagingSenderId: "908265107377",
  appId: "1:908265107377:web:89d0e3d0b9e826fd795790",
  measurementId: "G-JGD735MMYG"
};
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ======== GAME CODE ========
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let player, enemies = [], pickups = [];
    let keys = {};
    let timeSurvived = 0, lastDrop = 0, score = 0, gameOver = false;

    class Player {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.size = 24;
        this.color = "#4af";
        this.hp = 100;
        this.speed = 3;
        this.damage = 10;
        this.cooldown = 0;
        this.shield = 0;
      }
      update() {
        if (keys["w"] || keys["ArrowUp"]) this.y -= this.speed;
        if (keys["s"] || keys["ArrowDown"]) this.y += this.speed;
        if (keys["a"] || keys["ArrowLeft"]) this.x -= this.speed;
        if (keys["d"] || keys["ArrowRight"]) this.x += this.speed;
        this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
        this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
        if (this.cooldown > 0) this.cooldown--;
      }
      attack() {
        if (this.cooldown > 0) return;
        this.cooldown = 30;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255,255,0,0.3)";
        ctx.fill();
        enemies.forEach((e, i) => {
          const dist = Math.hypot(e.x - this.x, e.y - this.y);
          if (dist < this.size * 2) {
            e.hp -= this.damage;
            if (e.hp <= 0) {
              enemies.splice(i, 1);
              score += 10;
            }
          }
        });
      }
      takeDamage(amount) {
        if (this.shield > 0) { this.shield--; return; }
        this.hp -= amount;
        if (this.hp <= 0) gameOver = true;
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Enemy {
      constructor() {
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { this.x = 0; this.y = Math.random() * canvas.height; }
        if (edge === 1) { this.x = canvas.width; this.y = Math.random() * canvas.height; }
        if (edge === 2) { this.x = Math.random() * canvas.width; this.y = 0; }
        if (edge === 3) { this.x = Math.random() * canvas.width; this.y = canvas.height; }
        this.size = 20;
        this.color = "#f44";
        this.baseSpeed = 0.6 + Math.random() * 0.4;
        this.hp = 20;
        this.damage = 10;
      }
      update() {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const angle = Math.atan2(dy, dx);
        const minutes = timeSurvived / 60;
        const scale = 1 + Math.log(minutes + 1) * 0.4;
        this.speed = Math.min(this.baseSpeed * scale, this.baseSpeed * 3);
        this.x += Math.cos(angle) * this.speed;
        this.y += Math.sin(angle) * this.speed;
        if (Math.hypot(dx, dy) < player.size + this.size) {
          player.takeDamage(this.damage);
          this.hp = 0;
        }
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Pickup {
      constructor(type) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = 14;
        this.type = type;
        this.color = { health:"#0f0", shield:"#0ff", speed:"#ff0", damage:"#f0f", shockwave:"#fff" }[type];
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
      apply() {
        if (this.type === "health") player.hp = Math.min(100, player.hp + 20);
        if (this.type === "shield") player.shield = 3;
        if (this.type === "speed") { player.speed *= 1.6; setTimeout(()=>player.speed/=1.6,8000);}
        if (this.type === "damage") { player.damage *= 2; setTimeout(()=>player.damage/=2,10000);}
        if (this.type === "shockwave") {
          enemies.forEach(e => {
            const dist = Math.hypot(e.x - player.x, e.y - player.y);
            if (dist < 200) {
              e.hp -= 20;
              const ang = Math.atan2(e.y - player.y, e.x - player.x);
              e.x += Math.cos(ang)*100;
              e.y += Math.sin(ang)*100;
            }
          });
        }
      }
    }

    function spawnEnemy() { enemies.push(new Enemy()); }
    function spawnPickup() {
      const types = ["health","shield","speed","damage","shockwave"];
      pickups.push(new Pickup(types[Math.floor(Math.random()*types.length)]));
    }

    function drawHUD() {
      ctx.fillStyle = "#fff";
      ctx.font = "18px monospace";
      ctx.fillText(`HP: ${player.hp}`, 20, 30);
      ctx.fillText(`Shield: ${player.shield}`, 20, 55);
      ctx.fillText(`Score: ${score}`, 20, 80);
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      ctx.font = "36px monospace";
      ctx.fillText("GAME OVER", canvas.width / 2 - 120, canvas.height / 2);
      ctx.font = "20px monospace";
      ctx.fillText("Press any key to restart", canvas.width / 2 - 140, canvas.height / 2 + 40);
    }

    async function submitScore() {
      const name = prompt("Enter your name for the leaderboard:") || "Unknown";
      await addDoc(collection(db, "leaderboard"), { name, score, time: new Date().toISOString() });
      loadLeaderboard();
    }

    async function loadLeaderboard() {
      const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(5));
      const snap = await getDocs(q);
      const list = document.getElementById("scores");
      list.innerHTML = "";
      snap.forEach(doc => {
        const d = doc.data();
        const li = document.createElement("li");
        li.textContent = `${d.name}: ${d.score}`;
        list.appendChild(li);
      });
    }

    function restartGame() {
      player = new Player();
      enemies = [];
      pickups = [];
      timeSurvived = 0;
      lastDrop = 0;
      score = 0;
      gameOver = false;
      updateGame();
    }

    function updateGame() {
      if (gameOver) { submitScore(); drawGameOver(); return; }
      timeSurvived++;
      ctx.fillStyle = "#112";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (timeSurvived - lastDrop > 12 * 60) { spawnPickup(); lastDrop = timeSurvived; }
      if (timeSurvived % 120 === 0) spawnEnemy();
      player.update(); player.draw();
      pickups.forEach((p,i)=>{p.draw(); if(Math.hypot(player.x-p.x,player.y-p.y)<player.size+p.size){p.apply(); pickups.splice(i,1);}});
      enemies.forEach((e,i)=>{e.update(); e.draw(); if(e.hp<=0) enemies.splice(i,1);});
      drawHUD();
      requestAnimationFrame(updateGame);
    }

    document.addEventListener("keydown", e=>{
      keys[e.key]=true;
      if(gameOver) restartGame();
      if(e.key===" ") player.attack();
    });
    document.addEventListener("keyup", e=>keys[e.key]=false);

    window.onload = ()=>{ player=new Player(); loadLeaderboard(); updateGame(); };
  </script>
</body>
</html>
